 */const Es="6";try{window.__reactRouterVersion=Es}catch(e){}const Bs="startTransition",kt=Mr[Bs];function Ts(n){let{basename:e,children:r,future:s,window:a}=n,o=g.useRef();o.current==null&&(o.current=Kr({window:a,v5Compat:!0}));let i=o.current,[l,c]=g.useState({action:i.action,location:i.location}),{v7_startTransition:u}=s||{},d=g.useCallback(h=>{u&&kt?kt(()=>c(h)):c(h)},[c,u]);return g.useLayoutEffect(()=>i.listen(d),[i,d]),g.useEffect(()=>Fs(s),[s]),g.createElement(Ps,{basename:e,children:r,location:l.location,navigationType:l.action,navigator:i,future:s})}var jt;(function(n){n.UseScrollRestoration="useScrollRestoration",n.UseSubmit="useSubmit",n.UseSubmitFetcher="useSubmitFetcher",n.UseFetcher="useFetcher",n.useViewTransitionState="useViewTransitionState"})(jt||(jt={}));var Nt;(function(n){n.UseFetcher="useFetcher",n.UseFetchers="useFetchers",n.UseScrollRestoration="useScrollRestoration"})(Nt||(Nt={}));const rr=g.createContext(void 0),sr=()=>{const n=g.useContext(rr);if(!n)throw new Error("useTheme must be used within a ThemeProvider");return n},Ls=({children:n})=>{const[e,r]=g.useState("light");g.useEffect(()=>{console.log("[TRACE] useEffect in index-5JuZi7QJ.js");const o=localStorage.getItem("fractal-swap-theme"),i=window.matchMedia("(prefers-color-scheme: dark)").matches;o?r(o):i&&r("dark")},[]),g.useEffect(()=>{const o=window.document.documentElement;o.classList.remove("light","dark"),o.classList.add(e),localStorage.setItem("fractal-swap-theme",e)},[e]);const a={theme:e,toggleTheme:()=>{r(o=>o==="light"?"dark":"light")}};return t.jsx(rr.Provider,{value:a,children:n})},nr=g.createContext(void 0),lt=()=>{const n=g.useContext(nr);if(!n)throw new Error("useNetwork must be used within a NetworkProvider");return n},ue=[{name:"Fractal Bitcoin Testnet",type:"fractal_testnet",apiBase:"https://open-api-fractal.unisat.io",swapApi:"https://api-proxy.ddpurse.com",explorer:"https://explorer-fractal-testnet.unisat.io"},{name:"Fractal Bitcoin Mainnet",type:"fractal_mainnet",apiBase:"https://open-api-fractal.unisat.io",swapApi:"https://api-proxy.ddpurse.com",explorer:"https://explorer-fractal.unisat.io"}],Os=({children:n})=>{const[e,r]=g.useState(ue[0]),[s,a]=g.useState(null),[o,i]=g.useState([]);g.useEffect(()=>{const f="fractal_mainnet",v=ue.find(x=>x.type===f)||ue[0];r(v),l()},[]);const l=async()=>{const f=[{id:"layer-1",name:"Base Layer",level:1,status:"active",blockHeight:15e4,anchored:!0,congestion:"low",feeRate:1},{id:"layer-2.1",name:"Layer 2.1",level:2,status:"active",blockHeight:149950,anchored:!0,congestion:"medium",feeRate:2},{id:"layer-2.2",name:"Layer 2.2",level:2,status:"syncing",blockHeight:149900,anchored:!1,congestion:"high",feeRate:5}];i(f),a(f[0])},h={currentNetwork:e,availableNetworks:ue,currentLayer:s,availableLayers:o,switchNetwork:f=>{const v=ue.find(x=>x.type===f);v&&(r(v),l())},switchLayer:f=>{const v=o.find(x=>x.id===f);v&&a(v)},refreshLayers:async()=>{await l()}};return t.jsx(nr.Provider,{value:h,children:n})},Z=class Z{constructor(){I(this,"baseUrl");I(this,"network");I(this,"runesCache",new Map);I(this,"marketDataCache",new Map);I(this,"lastUpdate",new Map);I(this,"cacheTimeout",3e4);this.network="mainnet",this.baseUrl=this.network==="mainnet"?"https://open-api-fractal.unisat.io":"https://open-api-fractal-testnet.unisat.io"}static getInstance(){return Z.instance||(Z.instance=new Z),Z.instance}async getRunesBalances(e){console.log("[TRACE] async method in index-5JuZi7QJ.js");try{const r=`balances_${e}`,s=this.lastUpdate.get(r)||0;if(Date.now()-s<this.cacheTimeout&&this.runesCache.has(r))return this.runesCache.get(r);const a=await fetch(`${this.baseUrl}/v1/indexer/address/${e}/runes/balance-list`,{headers:{Accept:"application/json"}});if(!a.ok)throw new Error(`HTTP ${a.status}: ${a.statusText}`);const o=await a.json();if(o.code!==0)throw new Error(`API Error: ${o.msg}`);const i=o.data.detail||[];return this.runesCache.set(r,i),this.lastUpdate.set(r,Date.now()),console.log(`Fetched ${i.length} Runes balances for ${e}`),i}catch(r){console.error("Failed to fetch Runes balances:",r);const s=`balances_${e}`;return this.runesCache.has(s)?(console.warn("Returning stale cached data due to API error"),this.runesCache.get(s)):[]}}};async getRuneInfo(e){try{const r=await fetch(`${this.baseUrl}/v1/indexer/runes/${e}/info`,{headers:{Accept:"application/json"}});if(!r.ok)throw new Error(`HTTP ${r.status}: ${r.statusText}`);const s=await r.json();if(s.code!==0)throw new Error(`API Error: ${s.msg}`);return s.data}catch(r){return console.error(`Failed to fetch Rune info for ${e}:`,r),null}}async getRuneMarketData(e){try{const r=`market_${e}`,s=this.lastUpdate.get(r)||0;if(Date.now()-s<this.cacheTimeout&&this.marketDataCache.has(r))return this.marketDataCache.get(r);const a=await fetch(`${this.baseUrl}/v1/indexer/runes/${e}/market`,{headers:{Accept:"application/json"}});let o;if(a.ok){const i=await a.json();if(i.code===0)o=i.data;else{const l=await this.getRuneInfo(e);o={rune:(l==null?void 0:l.rune)||e,runeid:e,holders:(l==null?void 0:l.holders)||0}}}else{const i=await this.getRuneInfo(e);o={rune:(i==null?void 0:i.rune)||e,runeid:e,holders:(i==null?void 0:i.holders)||0}}return this.marketDataCache.set(r,o),this.lastUpdate.set(r,Date.now()),o}catch(r){return console.error(`Failed to fetch market data for ${e}:`,r),null}}async getTopRunes(e=50){var r;try{console.log(`üîÑ Fetching top ${e} Runes from market...`);const s=await fetch(`${this.baseUrl}/v1/indexer/runes/info-list?start=0&limit=${e}`,{headers:{Accept:"application/json","Content-Type":"application/json"}});if(!s.ok)throw new Error(`HTTP ${s.status}: ${s.statusText}`);const a=await s.json();if(a.code!==0||!((r=a.data)!=null&&r.detail))return console.warn("No top runes data available"),[];const o=a.data.detail.map(i=>{var l;return{rune:i.spacedRune||i.rune,runeid:i.runeid||((l=i.number)==null?void 0:l.toString())||i.spacedRune,spacedRune:i.spacedRune||i.rune,amount:"0",symbol:i.symbol||"",divisibility:i.divisibility||0}});return console.log(`‚úÖ Loaded ${o.length} top market Runes`),o}catch(s){return console.error("Failed to fetch top Runes:",s),[]}}async getAllRunes(e=100,r=0){try{const s=await fetch(`${this.baseUrl}/v1/indexer/runes/list?limit=${e}&offset=${r}`,{headers:{Accept:"application/json"}});if(!s.ok)throw new Error(`HTTP ${s.status}: ${s.statusText}`);const a=await s.json();if(a.code!==0)throw new Error(`API Error: ${a.msg}`);return a.data.detail||[]}catch(s){return console.error("Failed to fetch all Runes:",s),[]}}formatRuneAmount(e,r){const s=BigInt(e),a=BigInt(10**r);if(r===0)return s.toString();const o=s/a,i=s%a;if(i===0n)return o.toString();const c=i.toString().padStart(r,"0").replace(/0+$/,"");return`${o}.${c}`}parseRuneAmount(e,r){if(r===0)return e;const[s="0",a=""]=e.split("."),o=a.padEnd(r,"0").slice(0,r),i=BigInt(s)*BigInt(10**r),l=BigInt(o);return(i+l).toString()};getFormattedBalance(e){return this.formatRuneAmount(e.amount,e.divisibility)}clearBalanceCache(e){const r=`balances_${e}`;this.runesCache.delete(r),this.lastUpdate.delete(r)}clearAllCaches(){this.runesCache.clear(),this.marketDataCache.clear(),this.lastUpdate.clear()};getNetworkInfo(){return{network:this.network,baseUrl:this.baseUrl}}};I(Z,"instance");let Ce=Z;class Is{constructor(){I(this,"currentWallet",null);I(this,"requiredNetwork","fractal_mainnet")}async getAvailableWallets(){await this.waitForWalletExtensions();const e=[];return typeof window.unisat<"u"?e.push({name:"UniSat",icon:"/icons/unisat.png",installed:!0,connector:window.unisat}):e.push({name:"UniSat",icon:"/icons/unisat.png",installed:!1,connector:null}),typeof window.okxwallet<"u"?e.push({name:"OKX",icon:"/icons/okx.png",installed:!0,connector:window.okxwallet}):e.push({name:"OKX",icon:"/icons/okx.png",installed:!1,connector:null}),e}async waitForWalletExtensions(e=3e3){const r=Date.now(),s=100;return new Promise(a=>{const o=()=>{const i=Date.now()-r,l=typeof window.unisat<"u",c=typeof window.okxwallet<"u";if(l||c||i>=e){console.log(`üîç Wallet detection completed after ${i}ms`),console.log(`UniSat: ${l?"‚úÖ Available":"‚ùå Not found"}`),console.log(`OKX: ${c?"‚úÖ Available":"‚ùå Not found"}`),a();return}setTimeout(o,s)};o()})}async connect(e){let r;switch(e.toLowerCase()){case"unisat":if(!window.unisat)throw new Error("UniSat wallet not installed");r=window.unisat;break;case"okx":if(!window.okxwallet)throw new Error("OKX wallet not installed");r=window.okxwallet;break;default:throw new Error(`Unsupported wallet: ${e}`)}try{console.log(`üîó Connecting to ${e} wallet...`);try{await this.checkAndSwitchNetwork(r,e)}catch(l){console.warn("Network check failed, but proceeding with connection:",l.message)}const s=await r.requestAccounts();if(!s||s.length===0)throw new Error("No accounts found");const a=s[0];let o="";try{o=await r.getPublicKey()}catch(l){console.warn("Could not get public key:",l)}const i=await this.getWalletBalance(r,a);return this.currentWallet=e.toLowerCase(),console.log(`‚úÖ Successfully connected to ${e}`),console.log(`Address: ${a}`),console.log(`Balance: ${i}`),{address:a,publicKey:o,balance:i}}catch(s){throw console.error("Wallet connection failed:",s),new Error(`Failed to connect to ${e}: ${s.message}`)}}async checkAndSwitchNetwork(e,r){try{console.log(`üîç Checking network for ${r}...`),console.log(`Required network: ${this.requiredNetwork}`);let s=null;try{if(e.getNetwork?(s=await e.getNetwork(),console.log("wallet.getNetwork() returned:",s)):e.getChain?(s=await e.getChain(),console.log("wallet.getChain() returned:",s)):console.log("Wallet has no getNetwork() or getChain() method"),r.toLowerCase()==="unisat")try{if(e.getChainType){const a=await e.getChainType();console.log("UniSat getChainType():",a)};if(e.getBitcoinNetwork){const a=await e.getBitcoinNetwork();console.log("UniSat getBitcoinNetwork():",a)}}catch(err){console.log("UniSat-specific network methods not available")}}catch(a){console.warn("Could not detect current network:",a),console.log("‚ö†Ô∏è Network detection failed, proceeding with connection...");return};if(this.requiredNetwork==="fractal_mainnet"){const a=this.isOnBitcoinMainnet(s);if(a){console.log("‚úÖ Wallet is on Bitcoin mainnet (compatible with Fractal Bitcoin)");return}const o=this.isOnTestnet(s);if(o)throw console.log("‚ùå Wallet is on testnet, but we need mainnet"),new Error(`Please switch your ${r} wallet from testnet to mainnet`);console.log("‚ö†Ô∏è Could not clearly determine network, proceeding with connection..."),console.log("Network detection result - mainnet:",a,"testnet:",o);return}}catch(s){if(console.error("Network check failed:",s),s.message.includes("testnet")||s.message.includes("switch"))throw s;console.log("‚ö†Ô∏è Network check inconclusive, proceeding with connection...")}}isOnBitcoinMainnet(e){return e?[e==="livenet",e==="mainnet",e.network==="livenet",e.network==="mainnet",e.chainId==="bitcoin-mainnet",e.name==="Bitcoin Mainnet",e==="BITCOIN_MAINNET",e.type==="mainnet"].some(s=>s===!0):!1};isOnTestnet(e){return e?[e==="testnet",e.network==="testnet",e.chainId==="bitcoin-testnet",e.name==="Bitcoin Testnet",e==="BITCOIN_TESTNET",e.type==="testnet",e==="fractal-testnet",e.chainId==="fractal-testnet"].some(s=>s===!0):!1}isCorrectNetwork(e,r){return e?[e.chainId===r.chainId,e.network===r.chainId,e.name===r.networkName,e===r.chainId].some(a=>a===!0):!1}async requestNetworkSwitch(e,r,s){try{if(r.toLowerCase()==="unisat")await this.switchUnisatNetwork(e,s);else if(r.toLowerCase()==="okx")await this.switchOKXNetwork(e,s);else throw new Error("Network switching not supported for this wallet");console.log(`‚úÖ Successfully switched to ${s.networkName}`)}catch(a){throw console.error("Network switch failed:",a),new Error(`Failed to switch to ${s.networkName}. Please switch manually in your wallet.`)}}async switchUnisatNetwork(e,r){if(e.switchNetwork)await e.switchNetwork(r.chainId);else if(e.switchChain)await e.switchChain(r.chainId);else throw new Error(`Please manually switch UniSat to ${r.networkName}`)}async switchOKXNetwork(e,r){if(e.bitcoin&&e.bitcoin.switchNetwork)await e.bitcoin.switchNetwork(r.chainId);else throw new Error(`Please manually switch OKX to ${r.networkName}`)}async getCurrentNetwork(){const e=this.getCurrentWallet();if(!e)return null;try{let r=null;return e.getNetwork?r=await e.getNetwork():e.getChain&&(r=await e.getChain()),r?this.isOnBitcoinMainnet(r)?"bitcoin-mainnet":this.isOnTestnet(r)?"bitcoin-testnet":typeof r=="string"?r:JSON.stringify(r):null};catch(r){return console.warn("Could not get current network:",r),null}}async getRunesBalances(e){try{console.log(`üîç Fetching live Runes balances for address: ${e}`);const r=Ce.getInstance(),s=await r.getRunesBalances(e),a={};return s.forEach(o=>{const i=r.getFormattedBalance(o),l=parseFloat(i);o.runeid&&(a[o.runeid]=l),o.spacedRune&&(a[o.spacedRune]=l),o.symbol&&o.symbol!==o.spacedRune&&(a[o.symbol]=l),console.log(`‚úÖ Live Rune: ${o.spacedRune} (${o.runeid}) - Balance: ${i} ${o.symbol||""}`)}),console.log(`üìä Total Runes found: ${s.length}`),a}catch(r){return console.error("‚ùå Failed to fetch live Runes balances:",r),{}}}async getRuneBalance(e,r){try{return(await this.getRunesBalances(e))[r]||0};catch(s){return console.error(`Failed to get balance for rune ${r}:`,s),0}}async debugRunesBalanceAPI(e){const r="https://open-api-fractal.unisat.io";console.log("üîß DEBUG: Testing Runes balance API endpoints..."),console.log("Address:",e),console.log("API Base:",r);const s=[`/v1/indexer/address/${e}/runes/balance-list`,`/v1/indexer/address/${e}/runes`,`/v1/indexer/address/${e}/balance-list`,`/v1/indexer/runes/address/${e}/balance`,`/v1/indexer/runes/balance/${e}`,`/v1/indexer/address/${e}/runes-balance`,`/v1/indexer/address/${e}/assets`,`/v1/indexer/address/${e}/tokens`];for(const a of s)try{console.log(`
