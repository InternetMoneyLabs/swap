var y=Object.defineProperty;var T=(h,e,n)=>e in h?y(h,e,{enumerable:!0,configurable:!0,writable:!0,value:n}):h[e]=n;var w=(h,e,n)=>T(h,typeof e!="symbol"?e+"":e,n);import{w as u}from"./index-HAS52T4v.js";import"./vendor-Gm9i_4Ku.js";import"./bitcoin-DG-Uutyh.js";const d=class d{console.log("[TRACE] constructor in realWorldTradingService-Be3at9y3.js");w(this,"baseUrl","https://api.fractal-swap.com");w(this,"orders",new Map);w(this,"pools",new Map);w(this,"positions",new Map)}static getInstance(){return d.instance||(d.instance=new d),d.instance}console.log("[TRACE] async method in realWorldTradingService-Be3at9y3.js");const n=await u.getAccount();if(!n)throw new Error("Wallet not connected");const t={id:this.generateOrderId(),type:e.type,rune:e.rune,runeId:e.runeId,pricePerToken:e.pricePerToken,tokenAmount:e.tokenAmount,fbAmount:e.fbAmount,userAddress:n.address,signature:"",commitmentHash:"",status:"pending",createdAt:Date.now(),expiresAt:Date.now()+(e.expiryHours||24)*60*60*1e3,partialFills:[]},s=await this.createOrderCommitment(t);t.commitmentHash=s.hash;const o=this.createOrderMessage(t);t.signature=await u.signMessage(o);const r=await this.submitCommitmentOnChain(s);return await this.storeSecureOrder(t),console.log(`âœ… Secure limit order created: ${t.id}`),{orderId:t.id,commitmentTx:r}}async createOrderCommitment(e){const n=this.generateNonce(),t={type:e.type,rune:e.rune,price:e.pricePerToken,amount:e.tokenAmount,user:e.userAddress,expires:e.expiresAt,nonce:n};return{hash:await this.sha256(JSON.stringify(t)),nonce:n}}async submitCommitmentOnChain(e){`${e.hash}`,console.log("ðŸ“¡ Submitting order commitment on-chain..."),await new Promise(t=>setTimeout(t,2e3));const n=`commitment_${Date.now()}_${Math.random().toString(36).substr(2,8)}`;return console.log(`âœ… Commitment submitted: ${n}`),n}async storeSecureOrder(e){const n=await this.encryptOrderData(e);try{const t=await fetch(`${this.baseUrl}catch(error){console.log("[TRACE] auto-added catch in realWorldTradingService-Be3at9y3.js", error);}/orders`,{method:"POST",headers:{"Content-Type":"application/json",Authorization:`Bearer ${await this.getAuthToken()}`},body:JSON.stringify(n)});if(!t.ok)throw new Error(`Failed to store order: ${t.statusText}`);this.orders.set(e.id,e)}catch(t){throw console.error("Failed to store secure order:",t),new Error("Order storage failed - please try again")}}async matchOrders(){const e=Array.from(this.orders.values()).filter(s=>s.status==="active").sort((s,o)=>s.type==="buy"&&o.type==="buy"?o.pricePerToken-s.pricePerToken:s.type==="sell"&&o.type==="sell"?s.pricePerToken-o.pricePerToken:0),n=e.filter(s=>s.type==="buy"),t=e.filter(s=>s.type==="sell");for(const s of n)for(const o of t)s.rune===o.rune&&s.pricePerToken>=o.pricePerToken&&await this.executeTrade(s,o)}async executeTrade(e,n){const t=Math.min(e.tokenAmount,n.tokenAmount),s=n.pricePerToken;console.log(`ðŸ”„ Executing trade: ${t} ${e.rune} at ${s} sats each`);try{const o=await this.createAtomicSwapPSBT(e,n,t,s),r=await this.requestSignature(e.userAddress,o),a=await this.requestSignature(n.userAddress,o),i=await this.combineAndBroadcast(o,[r,a]);await this.updateOrdersAfterTrade(e,n,t,i),console.log(`âœ… Trade executed: ${i}catch(error){console.log("[TRACE] auto-added catch in realWorldTradingService-Be3at9y3.js", error);}`)}catch(o){throw console.error("Trade execution failed:",o),o}}async createLiquidityPool(e){const n=await u.getAccount();if(!n)throw new Error("Wallet not connected");const t=`${e.rune}_FB_${Date.now()}`,s=BigInt(Math.floor(e.initialRuneAmount*1e8)),o=BigInt(Math.floor(e.initialFBAmount*1e8)),r={id:t,tokenA:e.rune,tokenB:"FB",reserveA:s,reserveB:o,totalShares:BigInt(Math.floor(Math.sqrt(Number(s*o)))),fee:e.fee,createdBy:n.address,createdAt:Date.now()},a=await this.createPoolTransaction(r,n.address),i=await u.signPSBT(a);await this.broadcastTransaction(i),this.pools.set(t,r);const p={poolId:t,userAddress:n.address,shares:r.totalShares,tokenADeposited:s,tokenBDeposited:o,rewardsEarned:0n,createdAt:Date.now()},l=this.positions.get(n.address)||[];return l.push(p),this.positions.set(n.address,l),console.log(`âœ… Liquidity pool created: ${t}`),t}async addLiquidity(e,n,t){const s=await u.getAccount();if(!s)throw new Error("Wallet not connected");const o=this.pools.get(e);if(!o)throw new Error("Pool not found");const r=BigInt(Math.floor(n*1e8)),a=r*o.reserveB/o.reserveA;if(a>BigInt(Math.floor(t*1e8)))throw new Error(`Insufficient FB amount. Required: ${Number(a)/1e8} FB`);const i=r*o.totalShares/o.reserveA,p=await this.createAddLiquidityTransaction(o,s.address,r,a),l=await u.signPSBT(p),g=await this.broadcastTransaction(l);o.reserveA+=r,o.reserveB+=a,o.totalShares+=i;const c=this.positions.get(s.address)||[],m=c.find(f=>f.poolId===e);return m?(m.shares+=i,m.tokenADeposited+=r,m.tokenBDeposited+=a):c.push({poolId:e,userAddress:s.address,shares:i,tokenADeposited:r,tokenBDeposited:a,rewardsEarned:0n,createdAt:Date.now()}),this.positions.set(s.address,c),console.log(`âœ… Liquidity added to pool: ${e}`),g}async swapTokens(e){const n=await u.getAccount();if(!n)throw new Error("Wallet not connected");const t=this.pools.get(e.poolId);if(!t)throw new Error("Pool not found");const s=BigInt(Math.floor(e.amountIn*1e8));let o,r,a;if(e.tokenIn==="rune"){const c=s*BigInt(1e4-t.fee)/10000n;o=t.reserveB*c/(t.reserveA+c),r=t.reserveA+s,a=t.reserveB-o}else{const c=s*BigInt(1e4-t.fee)/10000n;o=t.reserveA*c/(t.reserveB+c),r=t.reserveA-o,a=t.reserveB+s}const i=BigInt(Math.floor(e.minAmountOut*1e8));if(o<i)throw new Error(`Slippage too high. Expected: ${e.minAmountOut}, Got: ${Number(o)/1e8}`);const p=await this.createSwapTransaction(t,n.address,e.tokenIn,s,o),l=await u.signPSBT(p),g=await this.broadcastTransaction(l);return t.reserveA=r,t.reserveB=a,console.log(`âœ… Swap executed: ${e.amountIn} ${e.tokenIn} â†’ ${Number(o)/1e8}`),g}generateOrderId(){return`ORDER_${Date.now()}_${Math.random().toString(36).substr(2,8).toUpperCase()}`}generateNonce(){return Math.random().toString(36).substr(2,16)}async sha256(e){const n=new TextEncoder().encode(e),t=await crypto.subtle.digest("SHA-256",n);return Array.from(new Uint8Array(t)).map(o=>o.toString(16).padStart(2,"0")).join("")}createOrderMessage(e){return`Fractal Swap Order
Type: ${e.type.toUpperCase()}
Rune: ${e.rune}
Price: ${e.pricePerToken} sats per token
Amount: ${e.tokenAmount} tokens
Expires: ${new Date(e.expiresAt).toISOString()}
Nonce: ${Date.now()}`}async encryptOrderData(e){return{...e,encrypted:!0,timestamp:Date.now()}}async getAuthToken(){return`auth_token_${Date.now()}`}async createAtomicSwapPSBT(e,n,t,s){return console.log("ðŸ”¨ Creating atomic swap PSBT..."),await new Promise(o=>setTimeout(o,1e3)),`psbt_swap_${Date.now()}`}async createPoolTransaction(e,n){return console.log("ðŸ”¨ Creating pool creation PSBT..."),await new Promise(t=>setTimeout(t,1e3)),`psbt_pool_${Date.now()}`}async createAddLiquidityTransaction(e,n,t,s){return console.log("ðŸ”¨ Creating add liquidity PSBT..."),await new Promise(o=>setTimeout(o,1e3)),`psbt_add_liquidity_${Date.now()}`}async createSwapTransaction(e,n,t,s,o){return console.log("ðŸ”¨ Creating swap PSBT..."),await new Promise(r=>setTimeout(r,1e3)),`psbt_swap_${Date.now()}`}async requestSignature(e,n){return console.log(`ðŸ“ Requesting signature from ${e}...`),await new Promise(t=>setTimeout(t,500)),`signature_${Date.now()}`}async combineAndBroadcast(e,n){return console.log("ðŸ“¡ Broadcasting transaction..."),await new Promise(t=>setTimeout(t,1500)),`tx_${Date.now()}_${Math.random().toString(36).substr(2,8)}`}async broadcastTransaction(e){return console.log("ðŸ“¡ Broadcasting transaction..."),await new Promise(n=>setTimeout(n,1e3)),`tx_${Date.now()}_${Math.random().toString(36).substr(2,8)}`}async updateOrdersAfterTrade(e,n,t,s){e.tokenAmount-=t,n.tokenAmount-=t;const o={id:`fill_${Date.now()}`,amount:t,price:n.pricePerToken,timestamp:Date.now(),txHash:s};e.partialFills.push(o),n.partialFills.push(o),e.tokenAmount===0?e.status="filled":e.status="partially_filled",n.tokenAmount===0?n.status="filled":n.status="partially_filled"}async getActiveOrders(e){const n=Array.from(this.orders.values());return e?n.filter(t=>t.userAddress===e&&t.status==="active"):n.filter(t=>t.status==="active")}async getLiquidityPools(){return Array.from(this.pools.values())}async getUserPositions(e){return this.positions.get(e)||[]}async cancelOrder(e){const n=this.orders.get(e);if(!n)throw new Error("Order not found");const t=await u.getAccount();if(!t||n.userAddress!==t.address)throw new Error("Unauthorized to cancel this order");n.status="cancelled",console.log(`âœ… Order cancelled: ${e}`)}};w(d,"instance");let A=d;export{A as default};
